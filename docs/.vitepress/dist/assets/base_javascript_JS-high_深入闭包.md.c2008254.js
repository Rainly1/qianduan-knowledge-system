import{_ as s,o as a,c as n,S as l}from"./chunks/framework.0fe8f473.js";const o="/qianduan-knowledge-system/assets/形成闭包内存图.962fcdaf.png",C=JSON.parse('{"title":"深入闭包","description":"","frontmatter":{},"headers":[],"relativePath":"base/javascript/JS-high/深入闭包.md","filePath":"base/javascript/JS-high/深入闭包.md"}'),p={name:"base/javascript/JS-high/深入闭包.md"},e=l(`<h1 id="深入闭包" tabindex="-1">深入闭包 <a class="header-anchor" href="#深入闭包" aria-label="Permalink to &quot;深入闭包&quot;">​</a></h1><h2 id="闭包概念" tabindex="-1">闭包概念 <a class="header-anchor" href="#闭包概念" aria-label="Permalink to &quot;闭包概念&quot;">​</a></h2><blockquote><p><span class="title-key">MDN 对 JavaScript 闭包的解释：</span></p><p>闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）的引用组合而成。 换言之，闭包让函数能访问它的外部作用域。在 JavaScript 中，闭包会随着函数的创建而同时创建。</p></blockquote><p><span class="title-key">理解总结：</span></p><ul><li>一个普通的函数 function，如果它们访问外层作用域的自由变量，那么这个函数就是一个闭包。</li><li>从广义说，JavaScript 的函数都是闭包。（解释：因为函数被创建出来，定义在最外层，其上层作用域就是全局作用域，如果在函数内引用了全局作用域的内容，也就形成了闭包）</li><li>从狭义说，JavaScript 中一个函数，如果访问了外层作用域的变量，那么她就是一个闭包。</li></ul><h2 id="函数执行过程的内存表现-闭包" tabindex="-1">函数执行过程的内存表现 &amp; 闭包 <a class="header-anchor" href="#函数执行过程的内存表现-闭包" aria-label="Permalink to &quot;函数执行过程的内存表现 &amp; 闭包&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Rain</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">小雨==&gt;</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">fn</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//小雨==&gt; Rain</span></span></code></pre></div><p><img src="`+o+`" alt="形成闭包内存图"></p><p><span class="key-word">解析：</span></p><ol><li>执行 <code>foo()</code>并创建执行上下文 <ul><li>代码开始执行，<code>foo()</code>被调用，创建一个执行上下文，并将该上下文压入上下文栈中。</li><li>在该执行上下文中会创建一个活动对象(AO)，其包含 foo()中的变量和函数声明。</li></ul></li><li>变量声明和初始化 <ul><li>在 foo()的活动对象(AO)中声明 <code>name</code> 变量，初始值为 <code>undefined</code>，并声明 <code>bar</code> 函数，将其引用指向 bar 函数的内存地址</li><li>当代码执行到<code>name = &quot;Rain&quot;</code>时，<code>name</code> 就被赋值为<code>“Rain”</code>,即 完成初始化。</li></ul></li><li>返回 bar 函数，形成闭包 <ul><li>当<code>return bar</code>被执行时，<code>foo()</code>的执行上下文随即完成并弹出栈，但由于 <code>bar</code> 函数被返回并赋值给 <code>fn</code>，<code>bar</code> 的引用不会被销毁。此时闭包形成，因为 <code>bar</code> 函数通过其内部的<code>[[scope]]</code>属性引用了 <code>foo</code> 的活动对象(AO),持有对其父作用域变量的访问权。</li><li><code>foo</code> 函数的执行上下文销毁，但闭包中的<code>name</code>变量仍然存在于 <code>foo</code> 的活动对象中，可以被 <code>bar</code> 引用。</li></ul></li><li>执行 <code>fn()</code>并使用闭包访问 <code>name</code> 变量 <ul><li>当执行 <code>fn()</code>（即 调用 <code>bar</code> 函数）时，<code>bar</code> 的执行上下文被创建。在执行 <code>bar</code> 的<code>console.log(&quot;小雨==&gt;&quot;, name)</code>时，bar 通过其<code>[[scope]]</code>属性找到父级作用域 foo 活动对象，进而访问并输出 <code>name</code> 变量的值<code>“Rain“</code>;</li></ul></li></ol><p><span class="title-key">结论：</span></p><ul><li><span class="key-word">闭包结构</span>：必报由函数本身和其引用的自由变量组成</li><li><span class="key-word">自由变量</span>：在闭包中，外层函数的变量，如 <code>name</code>，被称为 <span class="key-word-line">自由变量</span>。即使在最外层函数的执行上下文被销毁后，闭包函数依然可以访问这些变量。</li></ul><h2 id="闭包的内存泄漏" tabindex="-1">闭包的内存泄漏 <a class="header-anchor" href="#闭包的内存泄漏" aria-label="Permalink to &quot;闭包的内存泄漏&quot;">​</a></h2><h2 id="js-闭包引用的自由变量销毁" tabindex="-1">JS 闭包引用的自由变量销毁 <a class="header-anchor" href="#js-闭包引用的自由变量销毁" aria-label="Permalink to &quot;JS 闭包引用的自由变量销毁&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">小雨</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">age</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">20</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">bar</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">age</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">bar</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">fn</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> car </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#82AAFF;">car</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p><span class="key-word">解析：</span></p><ol><li>当 <code>fn = foo()</code>执行后，<code>fn</code> 指向第一个 <code>bar</code> 闭包。</li><li>当 <code>car = foo()</code>执行后，<code>car</code> 指向第二个 <code>bar</code> 闭包，它们是相互独立的。</li><li>当 <code>fn = null</code> 时，JavaScript 引擎会认为 <code>fn</code> 不再指向任何有效对象，触发垃圾回收机制来释放 <code>fn</code> 的闭包内存。</li></ol><p><span class="title-key">为什么 null 可以解除引用，而 undefined 不行？</span></p><ul><li>在 JS 中，垃圾回收依赖 <span class="key-word"> 引用计数 </span> 和 <span class="key-word"> 标记清除(可访问性) </span>来回收不再需要的对象。当一个对象设置为<code>null</code>时，该对象不再被任何变量引用，成为“不可达”对象。此时，垃圾回收器会识别它不再可用，从而释放内存。然而，将变量设置为<code>undefined</code>时，并不会断开对该对象的引用，因为<code>undefined</code>只是一个未赋值状态，并不表示 断开引用。 <ul><li><span class="key-word">断开引用</span>：断开变量与它所指的值或对象之间的联系。</li></ul></li></ul><h2 id="关联面试题" tabindex="-1">关联面试题 <a class="header-anchor" href="#关联面试题" aria-label="Permalink to &quot;关联面试题&quot;">​</a></h2><div class="tiwen"><div>闭包有何实际用途？闭包如何优化性能？闭包与模块化关系</div><div></div></div><ol><li>实际用途：</li></ol><ul><li>数据封装和私有变量</li><li>减少全局变量污染</li><li>模块化开发</li></ul><ol start="2"><li>性能优化</li></ol><ul><li>避免不必要的闭包</li><li>使用闭包时注意释放内存</li><li>控制闭包的层级</li><li>延迟加载</li></ul><ol start="3"><li>闭包与模块化的关系</li></ol><ul><li>提供私有变量</li><li>控制模块暴露的接口</li><li>模块重用</li></ul>`,27),c=[e];function t(r,i,y,F,d,D){return a(),n("div",null,c)}const u=s(p,[["render",t]]);export{C as __pageData,u as default};
