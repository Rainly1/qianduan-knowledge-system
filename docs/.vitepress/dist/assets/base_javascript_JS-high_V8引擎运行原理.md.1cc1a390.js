import{_ as a,o as e,c as i,S as l}from"./chunks/framework.1b3dd200.js";const o="/qianduan-knowledge-system/assets/V8-代码执行者CPU.df87cdd4.png",t="/qianduan-knowledge-system/assets/V8-字节码优化为机械代码过程.0b75701b.png",r="/qianduan-knowledge-system/assets/V8-拆解AST抽象树.c75e22a4.png",m=JSON.parse('{"title":"V8 引擎运行原理","description":"","frontmatter":{},"headers":[],"relativePath":"base/javascript/JS-high/V8引擎运行原理.md","filePath":"base/javascript/JS-high/V8引擎运行原理.md"}'),n={name:"base/javascript/JS-high/V8引擎运行原理.md"},s=l('<h1 id="v8-引擎运行原理" tabindex="-1">V8 引擎运行原理 <a class="header-anchor" href="#v8-引擎运行原理" aria-label="Permalink to &quot;V8 引擎运行原理&quot;">​</a></h1><h2 id="一、javascript-引擎" tabindex="-1">一、JavaScript 引擎 <a class="header-anchor" href="#一、javascript-引擎" aria-label="Permalink to &quot;一、JavaScript 引擎&quot;">​</a></h2><div class="tip-box"><div>学习JS引擎工作原理的理想选择：V8引擎。</div><div>V8引擎是Google开发的JavaScript引擎，广泛应用于Chrome浏览器和Node.js环境中。V8引擎实现了即时编译(JIT)，将JS代码直接编译成机器码，而非先转换为字节码。少一层转换消耗，明显提升运行效率(高性能)。V8不仅支持客户端JS执行，也支持服务器端的JS应用(跨平台)。V8提供了自动垃圾回收机制，管理内存的分配和释放，减少内存泄漏的风险。且是开源项目。 </div></div><h3 id="认识-javascript-引擎" tabindex="-1">认识 JavaScript 引擎 <a class="header-anchor" href="#认识-javascript-引擎" aria-label="Permalink to &quot;认识 JavaScript 引擎&quot;">​</a></h3><ol><li><p>JavaScript 引擎：解释和执行 JavaScript 代码的程序，负责将 JavaScript 代码转换成可执行的机器代码。这个过程包括 解析代码、进行优化，并最终执行。通过它，JS 能在浏览器或服务器环境中运行，处理从简单脚本到复杂应用的各种计算任务。</p></li><li><p>JavaScript 引擎作用：由于编写的 js 代码无论交给浏览器还是 Node 执行，最后都是需要被 CPU 执行的。所以我们需要 JavaScript 引擎将 js 代码翻译成 CPU 指令来执行。</p></li><li><p>常见的 JavaScript 引擎：..........</p></li></ol><h3 id="cpu-对于-js-引擎的意义" tabindex="-1">CPU 对于 JS 引擎的意义 <a class="header-anchor" href="#cpu-对于-js-引擎的意义" aria-label="Permalink to &quot;CPU 对于 JS 引擎的意义&quot;">​</a></h3><ol><li><p>CPU(中央处理器)是计算机的主要硬件之一，负责解释计算机程序中的指令以及处理计算机软件中的数据。它执行程序的基本算术、逻辑、控制和输入/输出(I/O)操作，指定这些操作的基本指令系统。CPU 是计算机的大脑，负责执行操作系统和应用程序的命令。现代 CPU 通常包括多个处理核心，这使它们能够同时处理多个任务。</p><ul><li><p><strong>即 JS 引擎是翻译官，CPU 是真正的代码执行者。</strong></p></li><li><p><img src="'+o+'" alt="代码执行者CPU"></p></li></ul></li></ol><h2 id="v8-引擎的原理" tabindex="-1">V8 引擎的原理 <a class="header-anchor" href="#v8-引擎的原理" aria-label="Permalink to &quot;V8 引擎的原理&quot;">​</a></h2><h3 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h3><ol><li>V8 是 C++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，用于 Chrome 和 Node.js 等。实现<code>ECMAScript</code>和<code>WebAssembly</code>，并在 Windows 7 或更高版本，macOS 10.12+和使用 x64,IA-32，ARM 或 MIPS 处理器的 Linux 系统上运行(兼容性很好)。V8 可以独立运行(很少这么做)，也可以嵌入到任何 C++应用程序中(如 Node.js)</li></ol><h3 id="v8-引擎处理流程" tabindex="-1">V8 引擎处理流程 <a class="header-anchor" href="#v8-引擎处理流程" aria-label="Permalink to &quot;V8 引擎处理流程&quot;">​</a></h3><ol><li>解析(Parse)：输入的 JS 源代码首先被<code>解析器(Parse)</code>处理，解析成 <code>抽象语法树(AST)</code>。这一步是编程语言的常规处理过程，目的是将源代码转换成结构化的、便于进一步处理的内部表示形式。</li><li>生成字节码(Bytecode)：AST 被<code>Ignition(V8的解释器)</code>处理，转换成字节码。字节码是介于源代码和机器代码之间的一种低级语言，比源代码更接近机器语言，但不是特定于任何单一的硬件。</li><li>执行字节码(Execution)：字节码随后被执行。在这一阶段，代码运行并进行实际的计算。</li><li>优化(Optimization)：<code>TurboFan(V8的优化编译器)</code>根据运行时的数据对字节码进行优化，生成优化的机器代码。优化的目的是提高代码的执行效率，通过诸如内联函数、消除冗余代码等技术来增强性能。</li><li>去优化(Deoptimization)：如果优化的假设在实际运行中不成立，优化的代码需要被去优化，回退到字节码执行。</li><li>生成机器代码(Machine Code)：优化后的代码被转换为机器代码，即直接由计算机硬件执行的代码。</li></ol><h4 id="词法分析和语法分析" tabindex="-1">词法分析和语法分析 <a class="header-anchor" href="#词法分析和语法分析" aria-label="Permalink to &quot;词法分析和语法分析&quot;">​</a></h4><ul><li><strong>词法分析：</strong> 编译过程中的第一阶段，主要任务是读取源代码的字符序列，将它们组合成有意义的“词素”(lexeme)，并产生相应的记号(token)。记号通常包括标识符、关键字、运算符等。</li><li><strong>语法分析：</strong> 编译第二阶段，在词法分析之后。它使用词法分析输出的记号序列，根据预定义的语法规则(通常以文法形式给出)，构建一个“语法树”的结构。</li><li><strong>词法和语法的区别：</strong> 词法分析是将代码分割成基础块并标记它们，而语法分析是将这些块组装成结构化的表达形式(即 AST 语法树)。 <ol><li>词法分析中，拆多细呢？会直接拆到拆不下去为止，是程序语法中的最小单元(即词法单元)。变量名、关键字等都是词法单元。</li><li>语法分析的过程，会检查代码是否符合 JavaScript 语言规范，再转化为 AST 语法树。</li></ol></li></ul><h4 id="中间字节码的作用" tabindex="-1">中间字节码的作用 <a class="header-anchor" href="#中间字节码的作用" aria-label="Permalink to &quot;中间字节码的作用&quot;">​</a></h4><ol><li>跨平台兼容。字节码与具体平台无关，无需针对每种硬件配置重新编译代码，就可以适应不同设备和操作系统。</li><li>性能优化 和 支持动态特性。在处理流程中，对字节码优化(优化方式：内联函数、消除冗余代码、简化循环等)，减少执行时不必要的开销，减轻了转化流程的性能损耗。 对优化好的代码进行检测，看是否成立，不成立就会回退反复进行，直到成立后才生成机器代码。（这一过程，结合了 即时编译 和动态优化 的思想，既保证了运行效率，也保证了代码的正确性。）</li><li>安全性。字节码为运行时提供了一个更加安全和控制的环境，可以有效地隔离恶意代码和系统资源。V8 引擎可以更容易实施安全策略和内存管理，毕竟我们不知道用户会传递进来什么样的代码。</li><li>便于程序员进行调试。V8 引擎选择字节码来辅助调试，权衡了性能和调试的便利性。字节码能够更好地支持逐步执行、设置断点和调试，而在机器代码级别这些操作会变得复杂和低效。通过这种取舍，V8 提供了既高效又易于调试的开发体验。 【虽然直接生成机器代码能够最大化性能，但在开发和调试阶段，使用字节码允许更高效的调试流程。这样即使性能有所折损，开发者仍然可以轻松找到问题并进行修复。】</li></ol><h4 id="全局对象" tabindex="-1">全局对象 <a class="header-anchor" href="#全局对象" aria-label="Permalink to &quot;全局对象&quot;">​</a></h4><ol><li>在 JavaScript 的<code>Parse解析</code>阶段，JS 引擎会为每个执行环境创建一个全局对象，V8 引擎为浏览器创建<code>window</code>对象，为 Node.js 创建<code>global</code>对象。 <ul><li>存放内容：全局对象包含了所有全局变量、全局函数、内建对象(r 如 String、Date、Number 等全局方法)。因此，可以直接在任何地方使用这些方法，而无需导入或实例化。</li><li>全局对象也存储了与宿主环境相关的属性和方法。在浏览器中，<code>window</code>对象存放了各种与页面交互的 API(<code>alert()</code>、<code>setTimeout()</code>)</li></ul></li><li><code>window</code>对象的自引用。因为<code>window</code>是 JavaScript 全局环境的跟对象，<code>window.window.window.xxx</code>任然指向相同的<code>window</code>对象。</li></ol><h4 id="执行上下文栈" tabindex="-1">执行上下文栈 <a class="header-anchor" href="#执行上下文栈" aria-label="Permalink to &quot;执行上下文栈&quot;">​</a></h4><ol><li>V8 引擎为了执行 js 代码，会维护一个 <strong>执行上下文栈</strong>，每当调用一个函数时，会创建一个新的上下文并推入栈中，当函数执行文笔，当前上下文会从栈中弹出。</li><li>全局上下文：在 JavaScript 程序运行时，首先创建的就是 <strong>全局执行上下文</strong>，并推入栈中。在浏览器中，全局执行上下文的<code>this</code>执行全局对象<code>window</code>。</li><li>函数上下文：当一个函数被调用时，会创建该函数的执行上下文，并在执行栈中逐层推入。当函数结束后，上下文从栈中弹出并返回到之前的上下文。</li></ol><ul><li><img src="'+t+'" alt="V8-字节码优化为机械代码过程"></li></ul><h2 id="v8-引擎的架构设计" tabindex="-1">V8 引擎的架构设计 <a class="header-anchor" href="#v8-引擎的架构设计" aria-label="Permalink to &quot;V8 引擎的架构设计&quot;">​</a></h2><h3 id="parse模块" tabindex="-1"><code>Parse模块</code> <a class="header-anchor" href="#parse模块" aria-label="Permalink to &quot;`Parse模块`&quot;">​</a></h3><p>JS 代码转换成 AST(抽象语法树)</p><ol><li>JS 代码中，所有的函数都会被解析为抽象语法树(AST)，无论它们是否被立即调用。这是因为即使函数没有被直接调用，它们可能会在将来作为回调函数或传递给其他函数。此外，函数内部可能包含需要提前处理的变量声明或表达式。因此，解析器不能因为函数此刻没有被调用而跳过它们，必须对所有代码进行分析，以构建完整的程序结构。</li></ol><h3 id="ignition作为解释器" tabindex="-1"><code>Ignition作为解释器</code> <a class="header-anchor" href="#ignition作为解释器" aria-label="Permalink to &quot;`Ignition作为解释器`&quot;">​</a></h3><ol><li>AST 转换成 ByteCode(字节码)，并在此过程中收集 TurboFan 需要的优化信息(如函数参数的类型信息，有了类型才能进行真实的运算)。当一个函数被调用时，Ignition 会解释执行生成的字节码。如果该函数只被调用一次，Ignition 国通解释执行来完成任务，而不会立刻进行优化。 Ignition 的 V8 官方文档：[<a href="https://v8.dev/blog/ignition-interpreter" target="_blank" rel="noreferrer">https://v8.dev/blog/ignition-interpreter</a>]</li></ol><h3 id="turbofan作为编译器" tabindex="-1"><code>TurboFan作为编译器</code> <a class="header-anchor" href="#turbofan作为编译器" aria-label="Permalink to &quot;`TurboFan作为编译器`&quot;">​</a></h3><ol><li><p><span class="title-key">热点函数优化</span>：将字节码编译为 CPU 可以直接执行的机器码。当一个函数被频繁调用，会被标记为 <span class="mark-key">热点函数</span>。这时，V8 会将该函数交给 TurboFan 编译器，生成更高效的 <span class="mark-key">机器码</span>。通过这种方式，热点代码的执行性能得到显著提升。</p></li><li><p><span class="title-key">去优化机制</span>：</p><ul><li><span class="title-key">类型变化导致的去优化</span>：如果函数输入类型发生变化（如从<code>number</code>类型变为<code>string</code>类型），之前生成的优化机器码可能无法处理这种变化。此时，V8 会通过一种<span class="mark-key">机逆向转换机制</span>，将机器码还原为未优化的字节码。</li><li><span class="title-key">解释器回退</span>：去优化后，代码执行回到 Ignition 解释器执行字节码。虽然机器码的执行被暂停，但 V8 仍会根据后续的性能分析，决定是否再次进行优化。</li></ul></li><li><p><span class="title-key">动态编译与执行</span>：最终，所有代码的执行都会在 CPU 层面进行，而 CPU 只接受 <strong>机器码</strong>。因此，即便代码暂时回退到字节码阶段，V8 仍可能会重新编译优化，确保代码能够高效运行。 TurboFan 的 V8 官方文档：[<a href="https://v8.dev/blog/turbofan-jit" target="_blank" rel="noreferrer">https://v8.dev/blog/turbofan-jit</a>]</p></li></ol><h3 id="预解析与全量解析" tabindex="-1">预解析与全量解析 <a class="header-anchor" href="#预解析与全量解析" aria-label="Permalink to &quot;预解析与全量解析&quot;">​</a></h3><p>在 JavaScript 解析过程中，存在两种主要的解析策略：预解析和全量解析</p><h4 id="预解析" tabindex="-1">预解析 <a class="header-anchor" href="#预解析" aria-label="Permalink to &quot;预解析&quot;">​</a></h4><ul><li>预解析是一种轻量、快速的解析方式，主要用于扫描代码的基本结构，如变量和函数声明。它不会深入分析函数体内的具体逻辑或表达式。</li><li>特点：速快，消耗少，因为不需要分析函数内部逻辑。生成的是简化版的抽象语法树(AST)，只包含必要的代码结构框架。主要用于提前构建程序的基本框架，帮助引擎识别哪些代码段需要进一步解析。</li></ul><h4 id="全量解析" tabindex="-1">全量解析 <a class="header-anchor" href="#全量解析" aria-label="Permalink to &quot;全量解析&quot;">​</a></h4><ul><li>全量解析是更深入的解析方式，分析整个代码文件，包括函数体内的所有语句和表达式。</li><li>特点：生成的 AST 更加完整，包含代码的全部细节信息。所有函数体内的逻辑在全量解析时都会被处理。如果一个函数被调用，全量解析会在调用之前进行，以确保所有逻辑都能正确执行。</li></ul><div class="tip-box"><h2>总结：</h2><div>1. 函数没有执行，只进行<span class="mark-key">预解析</span>，生成简化AST，提供基本的结构信息。</div><div>2. 函数执行时，才会进行<span class="mark-key">全量解析</span>，生成完整的AST，并继续转化为字节码。</div><div>3. 这种分层戒子机制提高了解析效率，是一种对性能的优化，减少了不必要的深度解析，降低了解析时间和内存消耗。</div></div><h3 id="v8-的转化代码过程" tabindex="-1">V8 的转化代码过程 <a class="header-anchor" href="#v8-的转化代码过程" aria-label="Permalink to &quot;V8 的转化代码过程&quot;">​</a></h3><p><a href="https://geekdaxue.co/read/lishengshidiwen@itk711/cbclam" target="_blank" rel="noreferrer">图解 Google V8</a><a href="https://astexplorer.net/" target="_blank" rel="noreferrer">拆解 AST 树网站</a></p><p><img src="'+r+'" alt="V8-拆解AST抽象树"></p><p>阐述如何拆解 AST 抽象语法树：</p><ul><li>Blink：起始阶段，JavaScript 代码以不同的编码(如 ASCII、Latin1、UTF-8)被读入，并转换为数据流(chunk)。</li><li>Stream：接收来自 Blink 阶段的数据，以 UTF-16 编码单元处理，准备进入下一步扫描。</li><li>Scanner：在这个阶段，流式传输的代码被扫描，转换成 tokens(标记)，这些标记是构建 AST(抽象语法树)的基本元素。</li><li>PreParser：对 tokens 进行预解析，以确定它们的结构，这有助于优化解析过程。</li><li>Parser：解析 tokens，构建 AST。AST 是源代码的树形结构的详细表现形式，用于指导后续的编译和优化。</li><li>Bytecode：AST 最终被编译成字节码，能被 V8 引擎快速执行或进一步优化成机器代码。</li></ul><p>参考文章</p><ul><li><a href="https://juejin.cn/post/7406139000284135463#heading-0" target="_blank" rel="noreferrer">掘金文章——JS 高级-V8 引擎的运行原理</a></li></ul>',43),d=[s];function c(h,p,u,b,S,v){return e(),i("div",null,d)}const k=a(n,[["render",c]]);export{m as __pageData,k as default};
