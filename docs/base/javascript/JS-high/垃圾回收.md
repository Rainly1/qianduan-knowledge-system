# 垃圾回收

<div class="tiwen">

- 由于 **内存的大小有限**，所以当 **内存不再需要的时候**，就需要对其进行释放，以便腾出更多的内存空间。
- 在手动管理内存语言中，需要通过一些方式自己来释放不再需要的内存，如 free 函数，但是：

  - <span class="key-word">容易产生内存泄漏：</span>如果忘记释放内存，程序运行时间越长，未释放的内存占用就会越多，可能导致内存耗尽。
  - <span class="key-word">开发负担大：</span>开发者需要频繁考虑内存的分配和释放，容易影响开发效率和代码的可读性。

- 所以，现代语言(如 Java，JavaScript，Python 等)通常有配备自己的垃圾回收机制，以减少内存管理带来的开发负担。
</div>

## 内存分配方式

在 JavaScript 中，内存分配时自动完成的，分为 <span class="key-word-line">栈(Stack) </span>和 <span class="key-word-line"> 堆(Heap) </span> 两种方式，分别用于不同类型的数据存储需求。

### 栈内存(Stack)

栈内存用于存储<span class="key-word-line">原始类型的变量</span> `number`、`string`、`boolean`、`undefined`、`null`、`symbol`、`bigInt`等，以及 对 <span class="key-word-line">引用类型的地址引用</span>。栈内存分配又称 静态内存分配。因为引擎会为那些值分配固定的内存，所以 **原始值的大小是有限的**

栈内存的特点：

- <span class="key-word">空间小、速度快</span>：栈内存分配和释放效率非常高，因为栈遵循“先进后出”原则的结构。
- <span class="key-word">自动管理</span>：当函数执行结束或局部变量超出作用域时，栈内存会自动回收。

**分配内存的大小取决于不同的浏览器各自的实现**

### 堆内存(Heap)

堆内存用于存储 **引用类型** 的值，对象、数组、函数等。堆内存 不会分配固定的内存空间，会根据需要分配更多的内存空间。

堆内存的特点：

- <span class="key-word">动态分配</span>：存储的空间较大，适合存储结构复杂、大小不确定的数据。
- <span class="key-word">手动回收</span>： JavaScript 的垃圾回收器会自动回收堆内存中的无用数据，但回收时间不确定，且存在一定的延迟。

| 栈                           | 堆                       |
| :--------------------------- | ------------------------ |
| 静态内存分配                 | 动态内存分配             |
| 原始值和指向对象与函数的引用 | 对象、数组、函数         |
| 在编译时确定分配内存大小     | 在运行时确定内存分配大小 |
| 分配固定的内存               | 没有大小限制             |

## 垃圾回收(GC)

> 垃圾回收(GC)是自动管理内存的重要机制，主要目的是找出程序不再使用的内存块并释放它们。
> JS 中常见的垃圾回收算法：**引用计数** 和 **标记清除**

### 引用计数

1. 原理：每个对象记录被引用的次数(引用计数)，每当有新的引用指向对象时，计数加一；引用断开时，计数减一。当计数变为零时，对象就被回收。
2. 优点：引用计数算法 简单，实时性强，对象一旦没有引用，可以立即清除没有引用的对象。
3. 缺点：但会产生 **循环引用** 的问题，即两个对象互相引用，导致计数永不为零，从而无法释放内存。这种情况下就陷入了死循环中，引用计数算法就无法回收它们，导致内存泄漏。

### 标记清除

1. 原理：该算法分为两个阶段———— **标记阶段** 和 **清除阶段**
   - **标记阶段：**从跟对象(如 全局对象、局部变量等)开始，递归遍历所有可以访问到的对象，并将它们标记为“可达”对象。
   - **清除阶段：**遍历内存中的所有对象，清除没有被标记为“可达”的对象，因为它们不再需要。
2. 优缺点：该算法能够很好的清理不再使用的对象，但会产生 **内存碎片**，影响内存使用效率。

### 分代回收算法

1. 分代收集 基于对象的生命周期，将堆内存划分为：<span class="key-word-line">新生代</span> 和 <span class="key-word-line">老年代</span>
   - 新生代：存放生命周期短的对象。垃圾回收器会频繁地检查并清理新生代，因为新对象的创建和销毁非常频繁。
   - 老年代：存放生命周期长的对象。垃圾回收器对老年代的检查和清理频率较低，因为这些对象大多长期存在。
2. 优点：
   - <span class="key-word">效率高</span>：新生代对象的清理操作较为快速，整体垃圾回收效率高。
   - <span class="key-word">减少暂停时间</span>：新生代的清理操作时间较短，减少了程序暂停时间。
3. 缺点：
   - <span class="key-word">复杂性</span>：实现和维护较为复杂，需要有效区分和管理新生代和老年代对象。
   - <span class="key-word">内存占用</span>：需要更多的内存来维护新生代和老年代的分带结构。

### V8 的垃圾回收机制

1. <span class="key-word">标记-清除</span>：对新生代对象进行快速标记和清除。
2. <span class="key-word">标记-压缩</span>：对老年代对象进行标记和压缩，以减少内存碎片。
3. <span class="key-word">增量标记</span>：将垃圾回收过程拆分为多个小步骤，穿插在正常的程序执行过程中，减少程序暂停时间。

### V8 引擎内存图

- V8 引擎会根据对象的生命周期和大小将它们分配到不同的内存块中，以优化内存的使用效率。

- ![V8引擎内存图](../image/V8%E5%BC%95%E6%93%8E%E5%86%85%E5%AD%98%E5%9B%BE.png)

<span class="title-key">对每个内存块的解释：</span>

- Old Space(老生代)：分配的内存较大，存储生命周期较长的对象，如 页面或浏览器的长时间使用对象。
- New Space(新生代)：分配的内存较小，存储生命周期较短的对象，如 临时变量、函数局部变量等。
- Large Object Space(大对象)：分配的内存较大，存储生命周期较长的大型对象，如 大数组、大字符串等。
- Code Space(代码空间)：存储编译后的函数代码和 JIT 代码。
- MAP Space(映射空间)：存储对象的属性信息，如 对象的属性名称、类型等信息。
- Cell Space(单元格空间)：存储对象的一些元信息，如 字符串长度、布尔类型等信息。

### 内存泄漏及预防

<span class="title-key">常见内存泄漏场景：</span>

1. <span class="key-word">意外的全局变量</span>：未使用 var、let 或 const 声明的变量会被挂载到全局对象上，导致内存无法被回收。
2. <span class="key-word">闭包</span>：不正确使用闭包，导致未使用的变量一直被引用。
3. <span class="key-word">事件监听器</span>：未正确移除的事件监听器，导致 DOM 元素无法被回收。
4. <span class="key-word">定时器</span>：未清理的 `setInterval` 或 `setTimeout` 回调函数。

<span class="title-key">预防措施：</span>

1. 避免全局变量：始终使用 var、let 或 const 声明的变量。
2. 正确使用闭包：确保闭包内引用的变量不再需要时，解除引用。
3. 移除事件监听器：及时移除不再需要的事件监听器。
4. 清理定时器：在适当的时候清理定时器。

### 垃圾回收的调优

1. 减少内存分配频率：尽量重用对象，减少新对象的创建频率。
2. 优化数据结构：选择合适的数据结构，避免内存浪费。
3. 监控内存使用：使用开发者工具监控内存使用情况，识别内存泄漏和热点区域。
4. 适当的垃圾回收策略：根据应用特点，选择适合的垃圾回收策略和配置参数。
