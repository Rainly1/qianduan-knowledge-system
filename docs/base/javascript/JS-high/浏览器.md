# 浏览器

## 一、浏览器工作原理

大概步骤：

1. URL 解析：
   - 浏览器访问任何页面，需要输入一个地址 URL(可以是域名，或者是 IP 地址)。将其分解成多个部分，如协议(http/https)、主机名、端口、路径等。
   - DNS 查询：如果是域名，浏览器通过 DNS(域名系统),将主机名(example.com)解析为对应的 IP 地址。
   - 建立链接：浏览器与服务器建立 TCP 连接，一般通过 三次握手 过程来确保可靠传输。如果使用的是 HTTPS 协议，还会进行 SSL/TLS 握手 以建立加密通信。
   - 发送请求：浏览器向服务器发送 HTTP 请求，通常是 GET 请求，用于获取网页资源。请求头信息包含诸如浏览器类型、支持的语言、Cookie 等内容。
2. 服务器响应：服务器接收到请求后，会处理并返回相应的资源，通常是 HTML 文档(index.html 入口文件)。响应包含：
   - 响应码：200、404、500 等
   - 响应头：描述资源的元数据，如内容类型(Content-Type)、缓存信息(Cache-Control)、服务器类型等。
   - 响应体：包括 HTML 页面、CSS 样式、JavaScript 文件、图像等资源。
3. 浏览器解析与渲染：
   - 解析 HTML：浏览器开始解析 HTML 文件，并构建 DOM 树。在解析过程中如遇到外部链接的 CSS(遇到 link 元素，发请求下载该元素的 href 属性指向的 CSS 文件) 或 JavaScript 文件(遇到 script 元素，发请求下载该元素的 src 属性指向的 JavaScript 文件)，浏览器会发起新的请求来下载这些文件。
   - 解析 CSS：在解析 HTML 的同时，浏览器还会解析所有的 CSS 文件以及`<style>`标签内的 css 样式，构建 CSSOM 树(CSS Object Model)。CSSOM 反映样式的树结构，与 DOM 结合，决定元素如何在页面上显示。
   - 解析 JavaScript：当浏览器遇到`<script>`标签时，会解析并执行 JavaScript 代码。如果 JavaScript 代码依赖于 DOM 或 CSSOM 的某些状态，浏览器会根据具体请求决定是否阻塞渲染，等待 JavaScript 执行完成。
     现代浏览器使用 JavaScript 引擎(V8 引擎)来解释并执行 JavaScript 代码。JavaScript 引擎会将代码编译为机器码并执行。
4. 渲染过程：
   - 构建渲染树。DOM 树和 CSSOM 树会组合生成一棵渲染树。渲染树包含每个可见元素的样式、位置等信息，用于最终的绘制。渲染树不包括那些不可见的元素(display:none 等的元素)。
   - 布局：浏览器通过 布局 过程，计算每个元素的具体大小和位置(回流)。
   - 绘制：布局完成后，浏览器开始将渲染树中的各个元素 绘制 到屏幕上。
5. 页面交互与更新：在渲染完成后，用户可以与页面进行交互，如点击按钮、填写表单等。当用户与页面互动时，JavaScript 代码可能会修改 DOM 树或 CSSOM 树，从而触发页面的 `重绘`或`回流`，页面动态更新。

![浏览器输入URL后的流程](../image/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B.png)

## 二、浏览器内核

1. 浏览器内核：浏览器中负责解析 HTML、CSS、JavaScript 等文件的核心组件，也被称为渲染引擎。
   常说的浏览器内核指 浏览器的排版引擎。也称浏览器引擎、页面渲染引擎或样板引擎。
2. 常见浏览器内核
   ![常见浏览器内核](../image//%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.png)

## 浏览器渲染整体过程

<div class="tip-box">
<div>浏览器渲染过程中，渲染引擎对HTML解析时，遇到JavaScript标签，会怎么办？</div>
<div>会停止解析HTML，而去加载和执行JavaScript代码</div>
</div>

![浏览器渲染过程](../image/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.png)

<h4>浏览器渲染过程详细解析：</h4>

- (1) 解析 HTML 文件，构建 DOM(文档对象模型)树。这个树代表了页面上所有元素的节点结构
- (2) 解析 CSS 文件，构建 CSSOM 树。
- (3) 将 DOM 树和 CSSOM 树合并成渲染树。
- (4) 生成布局树，计算每个元素在页面上的位置和大小。
- (5) 根据布局绘制渲染树，将渲染树上的元素绘制成屏幕上的像素。
- (6) 合成层，将多个图层合并成一个图层，以便使用 GPU 进行加速。
- (7) 使用 GPU 加速，对图层进行合并，形成最终的图像。
- (8) 如果发生重绘或回流操作，重新执行步骤 4-7。
- (9) 有些操作会触发重绘或回流，如改变元素的位置、大小、颜色等。这些操作会影响页面的性能和渲染速度，因此需要尽可能避免。

| 英文        | 中文        | 名词含义                                               |
| :---------- | ----------- | ------------------------------------------------------ |
| HTML Parser | HTML 解析器 | 解析 HTML 文档，从中构建出 DOM 树                      |
| DOM Tree    | DOM 树      | 表示 HTML 文档的树形结构，每个节点都是文档中的一个对象 |
| CSS Parser  | CSS 解析器  | 解析 CSS 文件或样式，生成页面的样式规则                |
| Style Rules | 样式规则    | CSS 解析后生成的具体样式指导，如字体大小、颜色等       |
| Attachment  | 附加        | 将样式规则附加到 DOM 树的过程，用于构建渲染树          |
| Render Tree | 渲染树      | 包含要渲染元素的 DOM 树的版本，不包括不可见的元素      |
| Layout      | 布局        | 计算每个元素的准确位置和大小，准备用于绘制             |
| Painting    | 绘制        | 根据布局和样式信息在屏幕上绘制内容的过程               |
| Display     | 显示        | 最终渲染和显示页面的阶段，用户在屏幕上看到的结果       |

### HTML 解析过程

HTML 解析过程，构建 DOM 树，是浏览器渲染页面的第一步。默认情况下，服务器会给浏览器返回 index.html 文件，故 解析 HTML 是所有步骤的开始。具体步骤：

1. 获取 HTML 文件 当用户在浏览器中输入网址时，浏览器会向服务器发送请求，请求下载网站的 HTML 文件。
2. HTML 标记识别 浏览器会将 HTML 文件解析成一个个标记(tag),如 div、p、img 等。解析的过程中，浏览器会忽略一些不合法的标记，如没有闭合标签、属性值没有使用引号等。
3. DOM 树构建 浏览器会将解析后的标记转化成一个个 DOM 节点(Node)，构建成一棵 DOM 树(Document Object Model)。DOM 树是一个树形结构，根节点是 document，其他节点代表 HTML 文档中的元素、属性、文本等。
   在构建 DOM 树的过程中，浏览器会按照 HTML 文档的层次结构，将文档分成一个个的块(block)，如文本块、段落块、表格块等。每个块都会被转换成一个 DOM 节点，节点之间的关系由 HTML 标记之间的关系来确定。

### 解析生成 CSS 规则

1. 在解析 HTML 文件的过程中，遇到 CSS 的 link 元素，浏览器会下载对应的 css 文件(下载 css 文件不会影响 DOM 的解析)，对 css 文件进行解析出对应的规则树 CSSOM。
2. 在 CSSOM 中，每个节点代表一个 css 规则，包括选择器(指定哪些元素会被应用这个规则)和声明(指定了这些元素的样式属性和值)。
3. CSSOM 树的构建过程类似于 DOM 树的构建过程，也是一个逐步解析的过程。

### 构建 RenderTree

1. 由于渲染树(Render Tree)在构建时，需要对应的 CSSOM Tree，所以 link 元素会阻塞 Render Tree 的构建过程。
2. Render Tree 和 DOM Tree 不是一一对应的关系。对于 display 为 none 的元素，不会在渲染树中出现，因为该元素被隐藏了，不会影响页面的呈现，因此也不需要在渲染树中进行渲染。

### 布局和绘制过程

1. 布局：确定呈现树中所有节点的宽度、高度和位置信息。
2. 绘制：将元素的可见部分进行绘制，如文本、颜色、边框、阴影、替换元素等。

### 回流和重绘

#### 回流的解析

回流：浏览器为了重新渲染部分或全部文档而重新计算文档中元素的位置和几何结构的过程。通常是因为元素的尺寸、布局、隐藏等属性发生变化引起的（回流代价高，会导致页面性能和响应速度下降）。
触发回流的情况：

- DOM 结构的变化，如添加、删除、移动元素等操作。
- 改变元素的布局，如修改元素的宽高、padding、margin、border、position、display 等属性。
- 页面的尺寸变化，如浏览器窗口大小的变化，或文档视口的变化。
- 获取元素的几何属性，如调用 getComputedStyle()方法获取元素的尺寸、位置等信息。

#### 重绘的解析

重绘：第一次渲染内容称为绘制，之后重新渲染称为 重绘。不需要重新计算元素的几何信息，只需要重新绘制元素的内容的过程。
触发重绘的情况：

- 修改元素的颜色、背景色、边框颜色、文本样式等属性。
- 修改元素的 box-shadow、text-shadow、outline 等属性。
- 使用 CSS3 transform 和 opacity 属性。
- 添加、移除、修改元素的 class(仅影响元素的外观部分)，如果改变影了元素的布局属性(宽高、边框、定位等)则会触发回流。
- 使用 JavaScript 直接修改样式

<div class="tip-box">
<h2 style="margin: 0">总结：</h2>
<div>回流一定会引起重绘，重绘不一定产生回流。回流很消耗性能</div>
<div>回流一定引起重绘原因：因为DOM操作或样式的改变导致了布局辩护。一旦元素的几何属性(宽高、位置、定位等)发生变化，浏览器需要重新计算元素的位置和大小，然后按照新的布局绘制元素。</div>

</div>

#### 页面性能优化

避免回流是提高页面性能的重要手段之一。常用优化方法：

- 尽量一次性修改样式可以使用`cssText属性`、`添加class`等方式，一次性修改元素的样式，避免多次修改引起页面的回流。
- 避免频繁的操作 DOM，可使用`DocumentFragment`或父元素来操作 DOM，避免频繁地操作 DOM 元素
- 避免使用 `getComputedStyle()`获取元素信息，`getComputedStyle()`会强制浏览器进行回流操作。如需要获取元素信息，可以在修改样式之前先保存到变量中，避免多次触发回流。
- **使用 position：absolute 或 position：fixed 属性** ，这样将元素从文档流中脱离出来，从而避免影响其他元素的位置和大小。

#### composite 合成

在浏览器绘制过程中，合成层(Compositing Layer)是一种优化手段，利用 GPU 加速页面渲染。默认情况下，所有页面内容都被绘制到同一个标准流图层中，但某些特定的情况或属性会创建新的合成层。每个合成层独立渲染，可以提高性能，尤其是在需要频繁更新某些元素时。
触发合成层创建的属性和条件：

1. 3D 变换：
   - `rotateX`、`rotateY`、`translateZ`等 3D 变换属性会创建新的合成层，因为它们依赖于 GPU 的加速渲染。
2. 特殊标签：
   - 嵌入式媒体标签如`video`、`canvas`、`iframe`自动创建合成层，以独立处理它们的内容。
3. 透明度动画：
   - 当元素的透明度(opacity)发生动画或过渡时，浏览器会创建一个新的合成层，以提高透明度变化的渲染效率、
4. 固定定位元素：
   - 具有`position:fixed`属性的元素会被放置在一个新的合成层中，这样可以避免由于页面滚动导致的重新布局和绘制问题。
5. will-change 属性：

   - 通过`will-change`告诉浏览器某个元素的样式可能会发生变化，浏览器会预先为该元素创建合成层，从而加快未来的变化响应速度。

6. 动画和过渡：

   - 设置了`opacity`和`transform`动画或过渡的元素会创建新的合成层，这样可以避免每次动画执行时重新绘制整个页面，提升性能。

**合成层的优势：**

- GPU 加速：合成层的创建可以利用 GPU 加速渲染，尤其是处理 3D 效果和复杂的动画时显著提升性能。
- 独立渲染：合成层独立于其它层，更新合成层中的元素不会引发整个页面的重排或重绘，因此更新效率更高。

**合成层的潜在问题：**

- 内存占用：每创建一个新的合成层都会占用额外的内存，合成层过多可能导致性能下降，尤其在内存有限的设备上。
- 页面复杂度增加：滥用合成层可能增加页面的复杂度，维护和调试时也会变得更加困难。

**合成层的合理使用：**

- 在需要高性能渲染时(如复杂动画、视频播放等)合理使用合成层。
- 避免滥用 will-change 等属性，只有在确实需要时才启用合成层，以免内存过度消耗。
