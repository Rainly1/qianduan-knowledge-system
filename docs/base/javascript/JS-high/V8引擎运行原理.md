# V8 引擎运行原理

## 一、JavaScript 引擎

<div class="tip-box">
<div>学习JS引擎工作原理的理想选择：V8引擎。</div>
<div>V8引擎是Google开发的JavaScript引擎，广泛应用于Chrome浏览器和Node.js环境中。V8引擎实现了即时编译(JIT)，将JS代码直接编译成机器码，而非先转换为字节码。少一层转换消耗，明显提升运行效率(高性能)。V8不仅支持客户端JS执行，也支持服务器端的JS应用(跨平台)。V8提供了自动垃圾回收机制，管理内存的分配和释放，减少内存泄漏的风险。且是开源项目。
</div>
</div>

### 认识 JavaScript 引擎

1. JavaScript 引擎：解释和执行 JavaScript 代码的程序，负责将 JavaScript 代码转换成可执行的机器代码。这个过程包括 解析代码、进行优化，并最终执行。通过它，JS 能在浏览器或服务器环境中运行，处理从简单脚本到复杂应用的各种计算任务。

2. JavaScript 引擎作用：由于编写的 js 代码无论交给浏览器还是 Node 执行，最后都是需要被 CPU 执行的。所以我们需要 JavaScript 引擎将 js 代码翻译成 CPU 指令来执行。

3. 常见的 JavaScript 引擎：..........

### CPU 对于 JS 引擎的意义

1. CPU(中央处理器)是计算机的主要硬件之一，负责解释计算机程序中的指令以及处理计算机软件中的数据。它执行程序的基本算术、逻辑、控制和输入/输出(I/O)操作，指定这些操作的基本指令系统。CPU 是计算机的大脑，负责执行操作系统和应用程序的命令。现代 CPU 通常包括多个处理核心，这使它们能够同时处理多个任务。

   - **即 JS 引擎是翻译官，CPU 是真正的代码执行者。**

   - ![代码执行者CPU](../image/V8-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%80%85CPU.png)

## V8 引擎的原理

### 介绍

1. V8 是 C++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，用于 Chrome 和 Node.js 等。实现`ECMAScript`和`WebAssembly`，并在 Windows 7 或更高版本，macOS 10.12+和使用 x64,IA-32，ARM 或 MIPS 处理器的 Linux 系统上运行(兼容性很好)。V8 可以独立运行(很少这么做)，也可以嵌入到任何 C++应用程序中(如 Node.js)

### V8 引擎处理流程

1. 解析(Parse)：输入的 JS 源代码首先被`解析器(Parse)`处理，解析成 `抽象语法树(AST)`。这一步是编程语言的常规处理过程，目的是将源代码转换成结构化的、便于进一步处理的内部表示形式。
2. 生成字节码(Bytecode)：AST 被`Ignition(V8的解释器)`处理，转换成字节码。字节码是介于源代码和机器代码之间的一种低级语言，比源代码更接近机器语言，但不是特定于任何单一的硬件。
3. 执行字节码(Execution)：字节码随后被执行。在这一阶段，代码运行并进行实际的计算。
4. 优化(Optimization)：`TurboFan(V8的优化编译器)`根据运行时的数据对字节码进行优化，生成优化的机器代码。优化的目的是提高代码的执行效率，通过诸如内联函数、消除冗余代码等技术来增强性能。
5. 去优化(Deoptimization)：如果优化的假设在实际运行中不成立，优化的代码需要被去优化，回退到字节码执行。
6. 生成机器代码(Machine Code)：优化后的代码被转换为机器代码，即直接由计算机硬件执行的代码。

#### 词法分析和语法分析

- **词法分析：** 编译过程中的第一阶段，主要任务是读取源代码的字符序列，将它们组合成有意义的“词素”(lexeme)，并产生相应的记号(token)。记号通常包括标识符、关键字、运算符等。
- **语法分析：** 编译第二阶段，在词法分析之后。它使用词法分析输出的记号序列，根据预定义的语法规则(通常以文法形式给出)，构建一个“语法树”的结构。
- **词法和语法的区别：** 词法分析是将代码分割成基础块并标记它们，而语法分析是将这些块组装成结构化的表达形式(即 AST 语法树)。
  1. 词法分析中，拆多细呢？会直接拆到拆不下去为止，是程序语法中的最小单元(即词法单元)。变量名、关键字等都是词法单元。
  2. 语法分析的过程，会检查代码是否符合 JavaScript 语言规范，再转化为 AST 语法树。

#### 中间字节码的作用

1. 跨平台兼容。字节码与具体平台无关，无需针对每种硬件配置重新编译代码，就可以适应不同设备和操作系统。
2. 性能优化 和 支持动态特性。在处理流程中，对字节码优化(优化方式：内联函数、消除冗余代码、简化循环等)，减少执行时不必要的开销，减轻了转化流程的性能损耗。
   对优化好的代码进行检测，看是否成立，不成立就会回退反复进行，直到成立后才生成机器代码。（这一过程，结合了 即时编译 和动态优化 的思想，既保证了运行效率，也保证了代码的正确性。）
3. 安全性。字节码为运行时提供了一个更加安全和控制的环境，可以有效地隔离恶意代码和系统资源。V8 引擎可以更容易实施安全策略和内存管理，毕竟我们不知道用户会传递进来什么样的代码。
4. 便于程序员进行调试。V8 引擎选择字节码来辅助调试，权衡了性能和调试的便利性。字节码能够更好地支持逐步执行、设置断点和调试，而在机器代码级别这些操作会变得复杂和低效。通过这种取舍，V8 提供了既高效又易于调试的开发体验。
   【虽然直接生成机器代码能够最大化性能，但在开发和调试阶段，使用字节码允许更高效的调试流程。这样即使性能有所折损，开发者仍然可以轻松找到问题并进行修复。】

#### 全局对象

1. 在 JavaScript 的`Parse解析`阶段，JS 引擎会为每个执行环境创建一个全局对象，V8 引擎为浏览器创建`window`对象，为 Node.js 创建`global`对象。
   - 存放内容：全局对象包含了所有全局变量、全局函数、内建对象(r 如 String、Date、Number 等全局方法)。因此，可以直接在任何地方使用这些方法，而无需导入或实例化。
   - 全局对象也存储了与宿主环境相关的属性和方法。在浏览器中，`window`对象存放了各种与页面交互的 API(`alert()`、`setTimeout()`)
2. `window`对象的自引用。因为`window`是 JavaScript 全局环境的跟对象，`window.window.window.xxx`任然指向相同的`window`对象。

#### 执行上下文栈

1. V8 引擎为了执行 js 代码，会维护一个 **执行上下文栈**，每当调用一个函数时，会创建一个新的上下文并推入栈中，当函数执行文笔，当前上下文会从栈中弹出。
2. 全局上下文：在 JavaScript 程序运行时，首先创建的就是 **全局执行上下文**，并推入栈中。在浏览器中，全局执行上下文的`this`执行全局对象`window`。
3. 函数上下文：当一个函数被调用时，会创建该函数的执行上下文，并在执行栈中逐层推入。当函数结束后，上下文从栈中弹出并返回到之前的上下文。

- ![V8-字节码优化为机械代码过程](../image/V8-%E5%AD%97%E8%8A%82%E7%A0%81%E4%BC%98%E5%8C%96%E4%B8%BA%E6%9C%BA%E6%A2%B0%E4%BB%A3%E7%A0%81%E8%BF%87%E7%A8%8B.png)

## V8 引擎的架构设计

### `Parse模块`

JS 代码转换成 AST(抽象语法树)

1. JS 代码中，所有的函数都会被解析为抽象语法树(AST)，无论它们是否被立即调用。这是因为即使函数没有被直接调用，它们可能会在将来作为回调函数或传递给其他函数。此外，函数内部可能包含需要提前处理的变量声明或表达式。因此，解析器不能因为函数此刻没有被调用而跳过它们，必须对所有代码进行分析，以构建完整的程序结构。

### `Ignition作为解释器`

1. AST 转换成 ByteCode(字节码)，并在此过程中收集 TurboFan 需要的优化信息(如函数参数的类型信息，有了类型才能进行真实的运算)。当一个函数被调用时，Ignition 会解释执行生成的字节码。如果该函数只被调用一次，Ignition 国通解释执行来完成任务，而不会立刻进行优化。
   Ignition 的 V8 官方文档：[https://v8.dev/blog/ignition-interpreter]

### `TurboFan作为编译器`

1. <span class="title-key">热点函数优化</span>：将字节码编译为 CPU 可以直接执行的机器码。当一个函数被频繁调用，会被标记为 <span class="mark-key">热点函数</span>。这时，V8 会将该函数交给 TurboFan 编译器，生成更高效的
   <span class="mark-key">机器码</span>。通过这种方式，热点代码的执行性能得到显著提升。
2. <span class="title-key">去优化机制</span>：

   - <span class="title-key">类型变化导致的去优化</span>：如果函数输入类型发生变化（如从`number`类型变为`string`类型），之前生成的优化机器码可能无法处理这种变化。此时，V8 会通过一种<span class="mark-key">机逆向转换机制</span>，将机器码还原为未优化的字节码。
   - <span class="title-key">解释器回退</span>：去优化后，代码执行回到 Ignition 解释器执行字节码。虽然机器码的执行被暂停，但 V8 仍会根据后续的性能分析，决定是否再次进行优化。

3. <span class="title-key">动态编译与执行</span>：最终，所有代码的执行都会在 CPU 层面进行，而 CPU 只接受 **机器码**。因此，即便代码暂时回退到字节码阶段，V8 仍可能会重新编译优化，确保代码能够高效运行。
   TurboFan 的 V8 官方文档：[https://v8.dev/blog/turbofan-jit]

### 预解析与全量解析

在 JavaScript 解析过程中，存在两种主要的解析策略：预解析和全量解析

#### 预解析

- 预解析是一种轻量、快速的解析方式，主要用于扫描代码的基本结构，如变量和函数声明。它不会深入分析函数体内的具体逻辑或表达式。
- 特点：速快，消耗少，因为不需要分析函数内部逻辑。生成的是简化版的抽象语法树(AST)，只包含必要的代码结构框架。主要用于提前构建程序的基本框架，帮助引擎识别哪些代码段需要进一步解析。

#### 全量解析

- 全量解析是更深入的解析方式，分析整个代码文件，包括函数体内的所有语句和表达式。
- 特点：生成的 AST 更加完整，包含代码的全部细节信息。所有函数体内的逻辑在全量解析时都会被处理。如果一个函数被调用，全量解析会在调用之前进行，以确保所有逻辑都能正确执行。

<div class="tip-box">
<h2>总结：</h2>
<div>1. 函数没有执行，只进行<span class="mark-key">预解析</span>，生成简化AST，提供基本的结构信息。</div>
<div>2. 函数执行时，才会进行<span class="mark-key">全量解析</span>，生成完整的AST，并继续转化为字节码。</div>
<div>3. 这种分层戒子机制提高了解析效率，是一种对性能的优化，减少了不必要的深度解析，降低了解析时间和内存消耗。</div>
</div>

### V8 的转化代码过程

[图解 Google V8](https://geekdaxue.co/read/lishengshidiwen@itk711/cbclam)
[拆解 AST 树网站](https://astexplorer.net/)

![V8-拆解AST抽象树](../image/V8-%E6%8B%86%E8%A7%A3AST%E6%8A%BD%E8%B1%A1%E6%A0%91.png)

阐述如何拆解 AST 抽象语法树：

- Blink：起始阶段，JavaScript 代码以不同的编码(如 ASCII、Latin1、UTF-8)被读入，并转换为数据流(chunk)。
- Stream：接收来自 Blink 阶段的数据，以 UTF-16 编码单元处理，准备进入下一步扫描。
- Scanner：在这个阶段，流式传输的代码被扫描，转换成 tokens(标记)，这些标记是构建 AST(抽象语法树)的基本元素。
- PreParser：对 tokens 进行预解析，以确定它们的结构，这有助于优化解析过程。
- Parser：解析 tokens，构建 AST。AST 是源代码的树形结构的详细表现形式，用于指导后续的编译和优化。
- Bytecode：AST 最终被编译成字节码，能被 V8 引擎快速执行或进一步优化成机器代码。

参考文章

- [掘金文章——JS 高级-V8 引擎的运行原理](https://juejin.cn/post/7406139000284135463#heading-0)
